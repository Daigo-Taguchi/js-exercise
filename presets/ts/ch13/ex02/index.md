## f3

### 予想

A が出力され、その後 C が出力される
エラー X は catch されずに、エラーが発生する。

### 結果

C が出力され、その後に A が出力される。
エラー X は catch されずにエラーが発生。

### 理由

wait は非同期の関数なので、その中でエラーが発生しても呼び出し元はコールスタックに存在しないので、例外を呼び出し元にスローできない。
したがって、 catch 節で例外を catch できないので、Bは表示されない。
try 節の中の wait(0) が実行されてすぐに finally が実行されるので、 C が出力されてから A が出力される

## f4

### 予想

2秒後に A が出力され、その1秒後に B が出力される。そして、100 が表示される

### 結果

予想と同じ

### 理由

wait2 の解決後に logA が出力、40 が return される
1つ目の .then の解決後に、1秒待機して、B が出力され、100 が return され、解決される
この 2つ目の .then が解決後に、3つ目の .then のコールバックが実行され、100 が出力される

### 図解

```
wait2
|----------|
           logA
           |-|
              wait(1000)
              |-----|
                    logB
                    |-|
                      log(100)
```

## f5

### 予想

2秒後に A が出力されてすぐに、undefined が表示される。1秒後に 100 が表示される。

### 結果

TS だと実行できない

## f6

### 予想

1秒後に A が出力される。A 出力の1秒後に B が出力され、その1秒後に C が出力される。

### 結果

予想と同じ

### 理由

wait1 の解決後に A が出力され、p が解決される。
2つ目の then で 1秒待機して B が出力される。
同時に 3つ目の then で 2秒待機して C が出力される。

### 図解

```
wait1
|----|
       logA
       |-|
         wait1
          |----|
               logB
         wait2
          |--------|
                   logC
```

## f7

## 予想

1秒後に A が出力される
その1秒後に B が出力され、C が出力される

## 結果

予想と同じ

### 理由

wait1 が解決後に A が出力される
wait2 が解決後に、p が解決されているか確認し、解決されているので B が出力され、2つめの then が解決される。
最後に C が出力される。

### 図解

```
wait1
|----|
     logA
     |-|
wait2
|--------|
         logB
         |-|
           logC
```

## f8

## 予想

1秒後に x のエラーメッセージが表示され、Y のエラーメッセージが表示、A が出力される

## 結果

X のエラーが表示されてから A が出力される

### 理由

1つ目の then でエラーが発生し、即座にエラーが伝播されるので解決されないため、2つ目の then は実行されない。
したがって、1秒待機してから X のエラーが発生し、catch ハンドラが実行され、X のエラーの内容が表示される。そして、finally は必ず最後に実行されるので、A が出力される。

### 図解

```
wait1
|----|
     errX
     |-|
       log(e.message)
       |-|
         logA
```

## f9

### 予想

1秒後に1つ目の then が実行されて解決され、2つ目の then が実行される
2つめの then でエラー Y が発生して、catch が実行され、エラー Y の内容が表示される。
最後に A が出力される

### 結果

予想と同じ

### 理由

予想に記載したものと同じ

### 図解

```
wait1
|----|
     errY
     |-|
       e.message
       |-|
         logA
```

## f10

### 予想

1秒後にエラー Y が発生して、Y のエラーメッセージが出力される。
その後、A が出力される

### 結果

1秒後に A が出力されてエラーY が発生する

### 理由

？

## f11

### 予想

エラーX が発生して X のエラーメッセージが表示される

### 結果

予想と同じ

### 理由

Promise 内で発生したエラーを catch でキャッチできて、エラーメッセージが表示された

## f12

### 予想

即座にエラーX が発生する

### 結果

予想と同じ

### 理由

new Promise 内で setTimeout の Promise が作成され、そのコールバック関数として errX が渡されて実行されている。setTimeout の Promise でエラーが発生しているが catch などで処理されていないので、そのままエラーが発生する。外側の catch ではエラーの処理ができない。
